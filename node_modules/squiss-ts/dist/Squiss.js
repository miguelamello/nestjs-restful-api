"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Squiss = void 0;
const events_1 = require("events");
const Message_1 = require("./Message");
const TimeoutExtender_1 = require("./TimeoutExtender");
const attributeUtils_1 = require("./attributeUtils");
const ts_type_guards_1 = require("ts-type-guards");
const client_sqs_1 = require("@aws-sdk/client-sqs");
const client_s3_1 = require("@aws-sdk/client-s3");
const gzipUtils_1 = require("./gzipUtils");
const s3Utils_1 = require("./s3Utils");
const messageSizeUtils_1 = require("./messageSizeUtils");
const Types_1 = require("./Types");
const Utils_1 = require("./Utils");
const url_1 = require("url");
const AWS_MAX_SEND_BATCH = 10;
class Squiss extends events_1.EventEmitter {
    get inFlight() {
        return this._inFlight;
    }
    get running() {
        return this._running;
    }
    constructor(opts) {
        super();
        this._running = false;
        this._paused = true;
        this._inFlight = 0;
        this._queueVisibilityTimeout = 0;
        this._queueMaximumMessageSize = 0;
        this._delQueue = new Map();
        this._opts = Object.assign({}, Types_1.optDefaults, opts || {});
        this._initOpts();
        this._queueUrl = this._opts.queueUrl || '';
        this.sqs = this._initSqs();
    }
    changeMessageVisibility(msg, timeoutInSeconds) {
        let receiptHandle;
        if (msg instanceof Message_1.Message) {
            receiptHandle = msg.raw.ReceiptHandle;
        }
        else {
            receiptHandle = msg;
        }
        return this.getQueueUrl()
            .then((queueUrl) => {
            return this.sqs.changeMessageVisibility({
                QueueUrl: queueUrl,
                ReceiptHandle: receiptHandle,
                VisibilityTimeout: timeoutInSeconds,
            });
        })
            .then(() => {
            return Promise.resolve();
        });
    }
    createQueue() {
        if (!this._opts.queueName) {
            return Promise.reject(new Error('Squiss was not instantiated with a queueName'));
        }
        const params = {
            QueueName: this._opts.queueName,
            Attributes: {
                ReceiveMessageWaitTimeSeconds: this._opts.receiveWaitTimeSecs.toString(),
                DelaySeconds: this._opts.delaySecs.toString(),
                MaximumMessageSize: this._opts.maxMessageBytes.toString(),
                MessageRetentionPeriod: this._opts.messageRetentionSecs.toString(),
            },
        };
        if (this._opts.visibilityTimeoutSecs) {
            params.Attributes.VisibilityTimeout = this._opts.visibilityTimeoutSecs.toString();
        }
        if (this._opts.queuePolicy) {
            params.Attributes.Policy = this._opts.queuePolicy;
        }
        return this.sqs.createQueue(params).then((res) => {
            this._queueUrl = res.QueueUrl;
            return res.QueueUrl;
        });
    }
    deleteMessage(msg) {
        if (!msg.raw) {
            return Promise.reject(new Error('Squiss.deleteMessage requires a Message object'));
        }
        const promise = new Promise((resolve, reject) => {
            this._delQueue.set(msg.raw.MessageId, { msg, Id: msg.raw.MessageId, ReceiptHandle: msg.raw.ReceiptHandle, resolve, reject });
        });
        msg.emit('delQueued');
        this.emit('delQueued', msg);
        this.handledMessage(msg);
        if (this._delQueue.size >= this._opts.deleteBatchSize) {
            if (this._delTimer) {
                clearTimeout(this._delTimer);
                this._delTimer = undefined;
            }
            this._deleteXMessages(this._opts.deleteBatchSize);
        }
        else if (!this._delTimer) {
            this._delTimer = setTimeout(() => {
                this._delTimer = undefined;
                this._deleteXMessages();
            }, this._opts.deleteWaitMs);
        }
        return promise;
    }
    deleteQueue() {
        return this.getQueueUrl()
            .then((queueUrl) => {
            return this.sqs.deleteQueue({ QueueUrl: queueUrl });
        })
            .then(() => {
            return Promise.resolve();
        });
    }
    getQueueUrl() {
        if (this._queueUrl) {
            return Promise.resolve(this._queueUrl);
        }
        const params = { QueueName: this._opts.queueName };
        if (this._opts.accountNumber) {
            params.QueueOwnerAWSAccountId = this._opts.accountNumber.toString();
        }
        return this.sqs.getQueueUrl(params).then(async (data) => {
            this._queueUrl = data.QueueUrl;
            if (this._opts.correctQueueUrl) {
                let newUrl;
                const endpoint = this.sqs.config.endpoint;
                /* istanbul ignore else  */
                if (typeof endpoint === 'string') {
                    newUrl = new url_1.URL(endpoint);
                }
                else if (typeof endpoint === 'function') {
                    const retrievedEndpoint = await endpoint();
                    if (retrievedEndpoint && typeof retrievedEndpoint === 'object') {
                        if ('url' in retrievedEndpoint) {
                            newUrl = new url_1.URL(retrievedEndpoint.url.toString());
                        }
                        if ('hostname' in retrievedEndpoint) {
                            const { protocol, hostname, port, path } = retrievedEndpoint;
                            // query params are ignored in setting endpoint.
                            newUrl = new url_1.URL(`${protocol}//${hostname}${port ? ':' + port : ''}${path}`);
                        }
                    }
                }
                /* istanbul ignore if */
                if (!newUrl) {
                    throw new Error(`Failed to get configured SQQ endpoint`);
                }
                const parsedQueueUrl = new url_1.URL(this._queueUrl);
                newUrl.pathname = parsedQueueUrl.pathname;
                this._queueUrl = newUrl.toString();
            }
            return this._queueUrl;
        });
    }
    getQueueVisibilityTimeout() {
        if (this._queueVisibilityTimeout) {
            return Promise.resolve(this._queueVisibilityTimeout);
        }
        return this.getQueueUrl().then((queueUrl) => {
            return this.sqs.getQueueAttributes({
                AttributeNames: ['VisibilityTimeout'],
                QueueUrl: queueUrl,
            });
        }).then((res) => {
            if (!res.Attributes || !res.Attributes.VisibilityTimeout) {
                throw new Error('SQS.GetQueueAttributes call did not return expected shape. Response: ' +
                    JSON.stringify(res));
            }
            this._queueVisibilityTimeout = parseInt(res.Attributes.VisibilityTimeout, 10);
            return this._queueVisibilityTimeout;
        });
    }
    getQueueMaximumMessageSize() {
        if (this._queueMaximumMessageSize) {
            return Promise.resolve(this._queueMaximumMessageSize);
        }
        return this.getQueueUrl().then((queueUrl) => {
            return this.sqs.getQueueAttributes({
                AttributeNames: ['MaximumMessageSize'],
                QueueUrl: queueUrl,
            });
        }).then((res) => {
            if (!res.Attributes || !res.Attributes.MaximumMessageSize) {
                throw new Error('SQS.GetQueueAttributes call did not return expected shape. Response: ' +
                    JSON.stringify(res));
            }
            this._queueMaximumMessageSize = parseInt(res.Attributes.MaximumMessageSize, 10);
            return this._queueMaximumMessageSize;
        });
    }
    handledMessage(msg) {
        this._inFlight--;
        if (this._paused && this._slotsAvailable()) {
            this._paused = false;
            this._startPoller()
                .catch((e) => {
                this.emit('error', e);
            });
        }
        msg.emit('handled');
        this.emit('handled', msg);
        if (!this._inFlight) {
            this.emit('drained');
        }
    }
    releaseMessage(msg) {
        this.handledMessage(msg);
        return this.changeMessageVisibility(msg, 0)
            .then((res) => {
            msg.emit('released');
            this.emit('released', msg);
            return res;
        });
    }
    purgeQueue() {
        return this.getQueueUrl()
            .then((queueUrl) => {
            return this.sqs.purgeQueue({ QueueUrl: queueUrl });
        })
            .then(() => {
            this._inFlight = 0;
            this._delQueue = new Map();
            this._delTimer = undefined;
            return Promise.resolve();
        });
    }
    sendMessage(message, delay, attributes) {
        return Promise.all([
            this._prepareMessageRequest(message, delay, attributes),
            this.getQueueUrl(),
        ])
            .then((data) => {
            const rawParams = data[0];
            const queueUrl = data[1];
            const params = {
                QueueUrl: queueUrl,
                ...rawParams,
            };
            return this.sqs.sendMessage(params);
        });
    }
    sendMessages(messages, delay, attributes) {
        return this.getQueueMaximumMessageSize()
            .then((queueMaximumMessageSize) => {
            return this._prepareMessagesToSend(messages, queueMaximumMessageSize, delay, attributes);
        })
            .then((batches) => {
            return Promise.all(batches.map((batch, idx) => {
                return this._sendMessageBatch(batch, delay, idx * AWS_MAX_SEND_BATCH);
            }));
        })
            .then((results) => {
            const successful = [];
            const failed = [];
            results.forEach((res) => {
                res.Successful?.forEach((elem) => successful.push(elem));
                res.Failed?.forEach((elem) => failed.push(elem));
            });
            return { Successful: successful, Failed: failed };
        });
    }
    start() {
        if (this._running) {
            return Promise.resolve();
        }
        this._running = true;
        return this._startPoller();
    }
    stop(soft, timeout) {
        if (!soft && this._activeReq) {
            this._activeReq.abort();
        }
        this._running = this._paused = false;
        if (!this._inFlight) {
            return Promise.resolve(true);
        }
        let resolved = false;
        let timer;
        return new Promise((resolve) => {
            this.on('drained', () => {
                if (!resolved) {
                    resolved = true;
                    if (timer) {
                        clearTimeout(timer);
                        timer = undefined;
                    }
                    resolve(true);
                }
            });
            timer = timeout ? setTimeout(() => {
                resolved = true;
                resolve(false);
            }, timeout) : undefined;
        });
    }
    getS3() {
        if (!this._s3) {
            this._s3 = this._initS3();
        }
        return this._s3;
    }
    _initS3() {
        if (this._opts.S3) {
            if (typeof this._opts.S3 === 'function') {
                return new this._opts.S3(this._opts.awsConfig || {});
            }
            else {
                return this._opts.S3;
            }
        }
        else {
            /* istanbul ignore next */
            return new client_s3_1.S3(this._opts.awsConfig || {});
        }
    }
    _initOpts() {
        if (!this._opts.queueUrl && !this._opts.queueName) {
            throw new Error('Squiss requires either the "queueUrl", or the "queueName".');
        }
        if (this._opts.s3Fallback && !this._opts.s3Bucket) {
            throw new Error('Squiss requires "s3Bucket" to be defined is using s3 fallback');
        }
        this._opts.deleteBatchSize = Math.min(this._opts.deleteBatchSize, 10);
        this._opts.receiveBatchSize = Math.min(this._opts.receiveBatchSize, this._opts.maxInFlight > 0 ? this._opts.maxInFlight : 10, 10);
        this._opts.minReceiveBatchSize = Math.min(this._opts.minReceiveBatchSize, this._opts.receiveBatchSize);
    }
    _deleteMessages(batch) {
        return this.getQueueUrl().then((queueUrl) => {
            return this.sqs.deleteMessageBatch({
                QueueUrl: queueUrl,
                Entries: batch.map((item) => {
                    return {
                        Id: item.Id,
                        ReceiptHandle: item.ReceiptHandle,
                    };
                }),
            });
        }).then(this._handleBatchDeleteResults(batch))
            .catch((err) => {
            this.emit('error', err);
        });
    }
    _emitMessages(messages) {
        messages.forEach((msg) => {
            const message = new Message_1.Message({
                squiss: this,
                unwrapSns: this._opts.unwrapSns,
                bodyFormat: this._opts.bodyFormat,
                msg,
                s3Retriever: this.getS3.bind(this),
                s3Retain: this._opts.s3Retain || false,
            });
            this._inFlight++;
            message.parse()
                .then(() => {
                this.emit('message', message);
            })
                .catch((e) => {
                this.emit('error', e);
                message.release();
            });
        });
    }
    _getBatch(queueUrl) {
        if (this._activeReq || !this._running) {
            return;
        }
        const maxMessagesToGet = this._getMaxMessagesToGet();
        if (maxMessagesToGet < this._opts.minReceiveBatchSize) {
            this._paused = true;
            return;
        }
        const params = (0, Utils_1.removeEmptyKeys)({
            QueueUrl: queueUrl, MaxNumberOfMessages: maxMessagesToGet,
            WaitTimeSeconds: this._opts.receiveWaitTimeSecs,
            MessageAttributeNames: this._opts.receiveAttributes,
            AttributeNames: this._opts.receiveSqsAttributes,
            VisibilityTimeout: this._opts.visibilityTimeoutSecs,
        });
        const controller = new AbortController();
        this._activeReq = controller;
        this.sqs.receiveMessage(params, {
            abortSignal: controller.signal,
        }).then(this._handleGetBatchResult(queueUrl)).catch((err) => {
            this._activeReq = undefined;
            if (err.name === 'AbortError') {
                this.emit('aborted', err);
            }
            else {
                setTimeout(this._getBatch.bind(this, queueUrl), this._opts.pollRetryMs);
                this.emit('error', err);
            }
        });
    }
    _initTimeoutExtender() {
        if (!this._opts.autoExtendTimeout || this._timeoutExtender) {
            return Promise.resolve();
        }
        return Promise.resolve().then(() => {
            if (this._opts.visibilityTimeoutSecs) {
                return this._opts.visibilityTimeoutSecs;
            }
            return this.getQueueVisibilityTimeout();
        }).then((visibilityTimeoutSecs) => {
            const opts = { visibilityTimeoutSecs };
            if (this._opts.noExtensionsAfterSecs) {
                opts.noExtensionsAfterSecs = this._opts.noExtensionsAfterSecs;
            }
            if (this._opts.advancedCallMs) {
                opts.advancedCallMs = this._opts.advancedCallMs;
            }
            this._timeoutExtender = new TimeoutExtender_1.TimeoutExtender(this, opts);
        });
    }
    _sendMessageBatch(messages, delay, startIndex) {
        const start = startIndex || 0;
        return this.getQueueUrl().then((queueUrl) => {
            const entries = [];
            const params = {
                QueueUrl: queueUrl,
                Entries: entries,
            };
            const promises = [];
            messages.forEach((msg, idx) => {
                const entry = {
                    Id: (start + idx).toString(),
                    ...msg,
                };
                entries.push(entry);
            });
            return Promise.all(promises)
                .then(() => {
                return this.sqs.sendMessageBatch(params);
            });
        });
    }
    _slotsAvailable() {
        return !this._opts.maxInFlight || this._inFlight < this._opts.maxInFlight;
    }
    _startPoller() {
        return this._initTimeoutExtender()
            .then(() => this.getQueueUrl())
            .then((queueUrl) => {
            this._getBatch(queueUrl);
        });
    }
    _deleteXMessages(x) {
        const delQueue = this._delQueue;
        const iterator = delQueue.entries();
        const delBatch = Array.from({ length: x || delQueue.size }, function () {
            const element = this.next().value;
            delQueue.delete(element[0]);
            return element[1];
        }, iterator);
        this._deleteMessages(delBatch);
    }
    _isLargeMessage(message, minSize) {
        const messageSize = (0, messageSizeUtils_1.getMessageSize)(message);
        if (minSize) {
            return Promise.resolve(messageSize > minSize);
        }
        return this.getQueueMaximumMessageSize()
            .then((queueMaximumMessageSize) => {
            return messageSize >= queueMaximumMessageSize;
        });
    }
    _prepareMessageParams(message, delay, attributes) {
        const messageStr = (0, ts_type_guards_1.isString)(message) ? message : JSON.stringify(message);
        const params = { MessageBody: messageStr, DelaySeconds: delay };
        attributes = Object.assign({}, attributes);
        params.MessageGroupId = attributes.FIFO_MessageGroupId;
        delete attributes.FIFO_MessageGroupId;
        params.MessageDeduplicationId = attributes.FIFO_MessageDeduplicationId;
        delete attributes.FIFO_MessageDeduplicationId;
        params.MessageAttributes = (0, attributeUtils_1.createMessageAttributes)(attributes);
        let getMessagePromise = Promise.resolve(messageStr);
        if (this._opts.gzip && (!this._opts.minGzipSize || (0, messageSizeUtils_1.getMessageSize)(params) >= this._opts.minGzipSize)) {
            getMessagePromise = (0, gzipUtils_1.compressMessage)(messageStr);
            params.MessageAttributes = params.MessageAttributes || {};
            params.MessageAttributes[gzipUtils_1.GZIP_MARKER] = {
                StringValue: `1`,
                DataType: 'Number',
            };
        }
        return getMessagePromise.then((finalMessage) => {
            params.MessageBody = finalMessage;
            return { finalMessage, params };
        });
    }
    _handleLargeMessagePrepare({ finalMessage, params }) {
        if (!this._opts.s3Fallback) {
            return Promise.resolve(params);
        }
        return this._isLargeMessage(params, this._opts.minS3Size)
            .then((isLarge) => {
            if (!isLarge) {
                return Promise.resolve(params);
            }
            return (0, s3Utils_1.uploadBlob)(this.getS3(), this._opts.s3Bucket, finalMessage, this._opts.s3Prefix || '')
                .then((uploadData) => {
                this.emit('s3Upload', uploadData);
                params.MessageBody = JSON.stringify(uploadData);
                params.MessageAttributes = params.MessageAttributes || {};
                params.MessageAttributes[s3Utils_1.S3_MARKER] = {
                    StringValue: `${uploadData.uploadSize}`,
                    DataType: 'Number',
                };
                return Promise.resolve(params);
            });
        });
    }
    _prepareMessageRequest(message, delay, attributes) {
        if (attributes && attributes[gzipUtils_1.GZIP_MARKER]) {
            return Promise.reject(new Error(`Using of internal attribute ${gzipUtils_1.GZIP_MARKER} is not allowed`));
        }
        if (attributes && attributes[s3Utils_1.S3_MARKER]) {
            return Promise.reject(new Error(`Using of internal attribute ${s3Utils_1.S3_MARKER} is not allowed`));
        }
        return this._prepareMessageParams(message, delay, attributes)
            .then(this._handleLargeMessagePrepare.bind(this))
            .then((params) => {
            return (0, Utils_1.removeEmptyKeys)(params);
        });
    }
    _initSqs() {
        if (this._opts.SQS) {
            if (typeof this._opts.SQS === 'function') {
                return new this._opts.SQS(this._opts.awsConfig || {});
            }
            else {
                return this._opts.SQS;
            }
        }
        else {
            return new client_sqs_1.SQS(this._opts.awsConfig || {});
        }
    }
    _handleBatchDeleteResults(batch) {
        const itemById = batch.reduce((prevByValue, item) => {
            prevByValue[item.Id] = item;
            return prevByValue;
        }, {});
        return (data) => {
            if (data.Failed?.length) {
                data.Failed.forEach((fail) => {
                    /* istanbul ignore next */
                    const item = itemById[fail.Id ?? ''];
                    this.emit('delError', { error: fail, message: item.msg });
                    item.msg.emit('delError', fail);
                    item.reject(fail);
                });
            }
            if (data.Successful?.length) {
                data.Successful.forEach((success) => {
                    /* istanbul ignore next */
                    const id = success.Id ?? '';
                    const item = itemById[id];
                    const msg = item.msg;
                    this.emit('deleted', { msg, successId: id });
                    msg.emit('deleted', id);
                    item.resolve();
                });
            }
        };
    }
    _prepareMessagesToSend(messages, queueMaximumMessageSize, delay, attributes) {
        const msgs = Array.isArray(messages) ? messages : [messages];
        const defaultAttributes = (attributes && !Array.isArray(attributes)) ? attributes : undefined;
        const arrayAttributes = (attributes && Array.isArray(attributes)) ? attributes : [];
        const promises = msgs.map((msg, i) => {
            return this._prepareMessageRequest(msg, delay, defaultAttributes || arrayAttributes[i]);
        });
        return Promise.all(promises)
            .then((requests) => {
            const batches = [];
            let currentBatchSize = 0;
            let currentBatchLength = 0;
            requests.forEach((message) => {
                const messageSize = (0, messageSizeUtils_1.getMessageSize)(message);
                if (currentBatchLength % AWS_MAX_SEND_BATCH === 0 ||
                    currentBatchSize + messageSize >= queueMaximumMessageSize) {
                    currentBatchLength = currentBatchSize = 0;
                    batches.push([]);
                }
                currentBatchSize += messageSize;
                currentBatchLength++;
                batches[batches.length - 1].push(message);
            });
            return batches;
        });
    }
    _handleGetBatchResult(queueUrl) {
        return (data) => {
            let gotMessages = true;
            this._activeReq = undefined;
            if (data && data.Messages) {
                this.emit('gotMessages', data.Messages.length);
                this._emitMessages(data.Messages);
            }
            else {
                this.emit('queueEmpty');
                gotMessages = false;
            }
            if (this._slotsAvailable()) {
                const next = this._getBatch.bind(this, queueUrl);
                if (gotMessages && this._opts.activePollIntervalMs) {
                    setTimeout(next, this._opts.activePollIntervalMs);
                }
                else if (!gotMessages && this._opts.idlePollIntervalMs) {
                    setTimeout(next, this._opts.idlePollIntervalMs);
                }
                else {
                    next();
                }
            }
            else {
                this._paused = true;
                this.emit('maxInFlight');
            }
        };
    }
    _getMaxMessagesToGet() {
        return !this._opts.maxInFlight ? this._opts.receiveBatchSize :
            Math.min(this._opts.maxInFlight - this._inFlight, this._opts.receiveBatchSize);
    }
}
exports.Squiss = Squiss;
//# sourceMappingURL=Squiss.js.map