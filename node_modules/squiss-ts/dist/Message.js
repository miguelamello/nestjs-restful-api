"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const attributeUtils_1 = require("./attributeUtils");
const events_1 = require("events");
const gzipUtils_1 = require("./gzipUtils");
const s3Utils_1 = require("./s3Utils");
const EMPTY_BODY = '{}';
class Message extends events_1.EventEmitter {
    static formatMessage(msg, format) {
        if (format === 'json') {
            return JSON.parse(msg || EMPTY_BODY);
        }
        else {
            return msg;
        }
    }
    constructor(opts) {
        super();
        this._opts = opts;
        this.raw = opts.msg;
        this.body = opts.msg.Body;
        if (opts.unwrapSns) {
            const unwrapped = JSON.parse(this.body || EMPTY_BODY);
            this.body = unwrapped.Message;
            this.subject = unwrapped.Subject;
            this.topicArn = unwrapped.TopicArn;
            if (this.topicArn) {
                this.topicName = unwrapped.TopicArn.substr(unwrapped.TopicArn.lastIndexOf(':') + 1);
            }
        }
        this._squiss = opts.squiss;
        this._handled = false;
        this.attributes = (0, attributeUtils_1.parseMessageAttributes)(opts.msg.MessageAttributes);
        this.sqsAttributes = opts.msg.Attributes || {};
        this._s3Retriever = opts.s3Retriever;
        this._s3Retain = opts.s3Retain;
    }
    parse() {
        if (this.body === undefined || this.body === null) {
            return Promise.resolve();
        }
        let promise = Promise.resolve(this.body);
        if (this.attributes[s3Utils_1.S3_MARKER]) {
            delete this.attributes[s3Utils_1.S3_MARKER];
            promise = this._getBlobMessage();
        }
        promise = promise
            .then((resolvedBody) => {
            if (this.attributes[gzipUtils_1.GZIP_MARKER] === 1) {
                delete this.attributes[gzipUtils_1.GZIP_MARKER];
                return (0, gzipUtils_1.decompressMessage)(resolvedBody);
            }
            else {
                return Promise.resolve(resolvedBody);
            }
        });
        return promise
            .then((parsedBody) => {
            this.body = Message.formatMessage(parsedBody, this._opts.bodyFormat);
        });
    }
    isHandled() {
        return this._handled;
    }
    del() {
        if (!this._handled) {
            this._handled = true;
            let promise;
            if (this._deleteCallback) {
                promise = this._deleteCallback();
            }
            else {
                promise = Promise.resolve();
            }
            return promise
                .then(() => {
                return this._squiss.deleteMessage(this);
            })
                .catch(() => {
                this._handled = false;
            });
        }
        else {
            return Promise.resolve();
        }
    }
    keep() {
        if (!this._handled) {
            this._squiss.handledMessage(this);
            this._handled = true;
        }
    }
    release() {
        if (!this._handled) {
            this._handled = true;
            return this._squiss.releaseMessage(this)
                .catch(() => {
                this._handled = false;
            });
        }
        return Promise.resolve();
    }
    changeVisibility(timeoutInSeconds) {
        return this._squiss.changeMessageVisibility(this, timeoutInSeconds);
    }
    _getBlobMessage() {
        const uploadData = JSON.parse(this.body);
        const s3 = this._s3Retriever();
        return (0, s3Utils_1.getBlob)(s3, uploadData)
            .then((resolvedBody) => {
            this.emit('s3Download', uploadData);
            this._squiss.emit('s3Download', { data: uploadData, message: this });
            if (!this._s3Retain) {
                this._deleteCallback = () => {
                    return (0, s3Utils_1.deleteBlob)(s3, uploadData)
                        .then(() => {
                        this.emit('s3Delete', uploadData);
                        this._squiss.emit('s3Delete', { data: uploadData, message: this });
                    });
                };
            }
            return Promise.resolve(resolvedBody);
        });
    }
}
exports.Message = Message;
//# sourceMappingURL=Message.js.map